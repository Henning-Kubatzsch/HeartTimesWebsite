<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Heart Times — Under Construction</title>
  <style>
    :root { --pink: #ff3ea5; --white: #ffffff; --black: #0b0b0c; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 15% 10%, #151518 0%, #0b0b0c 60%, #000 100%);
      color: var(--white);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, sans-serif;
      overflow: hidden;
    }

    /* Bühne: Canvas immer vollflächig, mobile-safe */
    #stage, #stage canvas {
      position: fixed;
      inset: 0;
      width: 100vw !important;
      height: 100dvh !important;
    }

    .noise {
      position: fixed; inset: 0; pointer-events: none; z-index: 1; opacity: .12; mix-blend-mode: screen;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="140" height="140"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="2" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23n)" opacity="0.25"/></svg>');
    }

    .overlay {
      position: relative; z-index: 2;
      height: 100dvh; width: 100vw;
      display: grid; place-items: center;
      padding: 24px; text-align: center;
      background: transparent;
    }

    .wrap { max-width: 900px; margin-inline: auto; }

    .brand { letter-spacing: .14em; text-transform: uppercase; font-weight: 900; opacity: .9; }
    .brand .glitch { position: relative; display: inline-block; font-size: clamp(28px, 5vw, 56px); text-shadow: 0 0 0 var(--white); }
    .brand .glitch::before, .brand .glitch::after { content: attr(data-text); position: absolute; inset: 0; pointer-events: none; mix-blend-mode: screen; }
    .brand .glitch::before { transform: translate(2px, 2px); color: var(--pink); filter: blur(.4px); }
    .brand .glitch::after { transform: translate(-2px, -2px); color: #9dffa9; filter: blur(.4px); }

    .uc { margin-top: 10px; font-size: clamp(18px, 3vw, 28px); font-weight: 800; letter-spacing: .12em; color: var(--white); }
    .tag { margin-top: 10px; font-size: clamp(14px, 2.2vw, 18px); opacity: .85; color: var(--white); }

    .cta {
      margin-top: 28px; display: inline-flex; gap: 12px; align-items: center;
      border: 2px dashed var(--pink); padding: 12px 16px; border-radius: 999px;
      color: var(--white); text-decoration: none; font-weight: 700;
    }
    .cta:hover { background: rgba(255, 62, 165, 0.08); }

    footer {
      position: fixed; bottom: 0; left: 0; right: 0; z-index: 2;
      padding: 6px 12px; display: flex; justify-content: center; gap: 8px;
      font-size: 12px; color: #c7c7d0; opacity: .9; background: transparent;
    }
    .bullet { color: var(--pink); margin: 0 8px; }
  </style>
</head>
<body>
  <div id="stage" aria-hidden="true"></div>
  <div class="noise" aria-hidden="true"></div>

  <main class="overlay">
    <div class="wrap">
      <div class="brand"><span class="glitch" data-text="HEART TIMES">HEART TIMES</span></div>
      <div class="uc">UNDER CONSTRUCTION</div>
      <div class="tag">MTB / GRAVEL — queer, loud. Back soon.</div>
      <a class="cta" href="mailto:kontakt@heart-times.de">kontakt@heart-times.de</a>
    </div>
  </main>

  <footer>
    © 2025 Heart Times <span class="bullet"></span>
  </footer>

  <!-- Three.js laden -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <!-- Dein Code (ohne String, normale Typerkennung/Syntax-Highlighting) -->
  <script>
    // ----- Setup
    const container = document.getElementById('stage');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.8));
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 200);

    const clock = new THREE.Clock();
    const orbitSpeed = 0.25; // Umdrehungen pro Sekunde * 2π? siehe unten

    //Lights
    
    scene.add(new THREE.AmbientLight(0xffffff, 0.2));
    const pinkLight = new THREE.PointLight(0xff3ea5, 20, 200, 2.0);
    pinkLight.position.set(36, 42, 50);
    scene.add(pinkLight);
    const rim = new THREE.DirectionalLight(0xffffff, 0.8);
    rim.position.set(-60, -20, 80);
    scene.add(rim);

    // Heart geometry (zentriert)
    function makeHeartMesh() {
        const x = 0, y = 0;
        const shape = new THREE.Shape();
        shape.moveTo(x + 25, y + 25);
        shape.bezierCurveTo(x + 25, y + 25, x + 20, y + 0, x + 0, y + 0);
        shape.bezierCurveTo(x - 30, y + 0, x - 30, y + 35, x - 30, y + 35);
        shape.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95);
        shape.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35);
        shape.bezierCurveTo(x + 80, y + 35, x + 80, y + 0, x + 50, y + 0);
        shape.bezierCurveTo(x + 35, y + 0, x + 25, y + 25, x + 25, y + 25);

        const geom = new THREE.ExtrudeGeometry(shape, {
            depth: 16, steps: 2, bevelEnabled: true, bevelThickness: 3.6, bevelSize: 2.8, bevelSegments: 10, curveSegments: 32,
        });
        geom.center();
      
        const mat = new THREE.MeshStandardMaterial({
            color: 0xff3ea5, 
            metalness: 0.8, 
            roughness: 0.15, 
            emissive: 0xff3ea5, 
            emissiveIntensity: 0.32,
        });
    
        const mesh = new THREE.Mesh(geom, mat);
        mesh.rotation.x = Math.PI;
        mesh.scale.setScalar(0.15);
        return mesh;
    }

    const heart = makeHeartMesh();
    const pivot = new THREE.Group();
    pivot.add(heart);
    scene.add(pivot);
    
    // --- Rotierende Spotlights (links/rechts)
    const orbit = new THREE.Group();
    scene.add(orbit);

    // gemeinsamer Target-Punkt (Mitte des Herzens)
    const lightTarget = new THREE.Object3D();
    pivot.add(lightTarget); // Target rotiert/atmet mit dem Herz-Zentrum

    // SpotLight-Factory
    function makeSpot(color) {
    const spot = new THREE.SpotLight(color, 10, 180, Math.PI / 7, 0.25, 2.0);
    spot.castShadow = false;              // falls nötig: true + Shadow-Setup
    spot.target = lightTarget;            // auf Herz zielen
    return spot;
    }

    const leftSpot  = makeSpot(0xff3ea5);   // pink
    const rightSpot = makeSpot(0xffffff);   // weiß (Kontrast)

    // Startpositionen (spiegeln)
    leftSpot.position.set(-40, 20, 30);
    rightSpot.position.set( 40, 20, 30);

    // leichtes Farb-Glühen per Helfer (optional): sichtbare Lichtkegel
    // (Wenn du sichtbare Volumina willst, bräuchte es Volumetrics/Shader – hier nur die Lichtquellen.)
    orbit.add(leftSpot, leftSpot.target, rightSpot, rightSpot.target);



    // BoundingSphere & Kamera-Fit (nachdem Objekt in Scene ist)
    function getBoundingSphere() {
      pivot.updateWorldMatrix(true, true);
      const box = new THREE.Box3().setFromObject(pivot);
      return box.getBoundingSphere(new THREE.Sphere());
    }

    function fitCameraToObject() {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.8));
      camera.aspect = w / h;
      camera.updateProjectionMatrix();

      const sphere = getBoundingSphere();
      const fov = THREE.MathUtils.degToRad(camera.fov);
      const fitHeightDistance = sphere.radius / Math.sin(fov / 2);
      const fitWidthDistance  = sphere.radius / Math.tan(fov / 2) / camera.aspect;
      //const distance = Math.max(fitHeightDistance, fitWidthDistance) * 1.2;
      const distance = Math.max(fitHeightDistance, fitWidthDistance) * 0.9;


      camera.position.set(0, 8, distance);
      camera.lookAt(sphere.center);
    }

    fitCameraToObject();
    window.addEventListener('resize', fitCameraToObject);

    // Drag inertia
    let isDown = false, lastX = 0, lastY = 0, vx = 0, vy = 0;
    const damp = 0.95;
    function onDown(e){ isDown = true; lastX = (e.touches? e.touches[0].clientX : e.clientX); lastY = (e.touches? e.touches[0].clientY : e.clientY); }
    function onMove(e){ if(!isDown) return; const x = (e.touches? e.touches[0].clientX : e.clientX); const y = (e.touches? e.touches[0].clientY : e.clientY); vx = (x - lastX) * 0.005; vy = (y - lastY) * 0.005; pivot.rotation.y += vx; pivot.rotation.x += vy; lastX = x; lastY = y; }
    function onUp(){ isDown = false; }
    renderer.domElement.addEventListener('mousedown', onDown);
    renderer.domElement.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    renderer.domElement.addEventListener('touchstart', onDown, { passive: true });
    renderer.domElement.addEventListener('touchmove', onMove, { passive: true });
    window.addEventListener('touchend', onUp);

    // Puls @ 60 BPM
    const bpm = 60; const freq = bpm / 60; const amp = 0.06; 
    const baseScale = 0.15;
    function animate(){

      const t = clock.getElapsedTime();
      const dt = clock.getDelta();
      const s = 1 + amp * Math.sin(2 * Math.PI * freq * t);
      heart.scale.setScalar(baseScale * s);
      orbit.rotation.y += orbitSpeed * dt; 


      const glow = 0.28 + 0.22 * (0.5 + 0.5 * Math.sin(2 * Math.PI * freq * t));
      heart.material.emissiveIntensity = glow;
      
      
      //pinkLight.intensity = 18 + 10 * (0.5 + 0.5 * Math.sin(2 * Math.PI * freq * t));

      if(!isDown){ pivot.rotation.y += vx; pivot.rotation.x += vy; vx *= damp; vy *= damp; }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
